# Day 3

## Info - Openshift S2I 
<pre>
- Unlike Kubernetes, Openshift apart from deploying application from readily available or pre-built custom docker image, one could deploy application from source code from your version control
- S2I stands for Source to Image, i.e Openshift will build the custom image based on your application source code
- Openshift S2I supports many different strategies
  1. Docker
  2. Source
  3. Custom
  4. Pipeline(Jenkins/TekTon)
  5. Binary(S2I Binary)
</pre>

## Info - Openshift S2I Docker Strategy
<pre>
- You will have to provide your Version control url, for example - https://github.com/tektutor/spring-ms.git
- The GitHub url should have your application source code and Dockerfile
- BuildConfig will be autogenerated by Openshift
- Application will be build to create application binary, using your application binary it will create a custom image as per your instructions in the Dockerfile
- the custom image built will then be pushed into Openshift Internal Image Registry
- It will then deploy your application using the image it pushed into Openshift Internal Image Registry
- It will automatically create BuildConfig and ImageStream, Deployment and Service
- You need to expose the source to creeate a route ( a public url to access the application )
  oc expose svc/hello
- You can then access the application using the route url from command-line or from the web console
</pre>

## Info - Openshift S2I Docker Strategy
<pre>
- You will have to provide your Version control url, for example - https://github.com/tektutor/spring-ms.git
- The GitHub url must have just the source code, Dockerfile is not required even if is there it will be ignored in the source strategy
- BuildConfig will be autogenerated by Openshift
- Application will be build to create application binary, using your application binary it will create a custom image as per the autogenerated Dockerfile instructions
- the custom image built will then be pushed into Openshift Internal Image Registry
- It will then deploy your application using the image it pushed into Openshift Internal Image Registry
- It will automatically create BuildConfig and ImageStream, Deployment and Service
- You need to expose the source to creeate a route ( a public url to access the application )
  oc expose svc/hello
- You can then access the application using the route url from command-line or from the web console
</pre>


## Lab - Deploying the application using S2I docker strategy
```
oc delete project jegan
oc new-project jegan

oc new-app --name=hello https://github.com/tektutor/spring-ms.git --strategy=docker
oc expose svc/hello

oc logs -f bc/hello
```

<img width="1920" height="1168" alt="image" src="https://github.com/user-attachments/assets/ec5f1fed-12f4-4e65-b36b-a522e563052c" />
<img width="1920" height="1168" alt="image" src="https://github.com/user-attachments/assets/3215ca29-c395-481a-a283-63c1ce78c402" />
<img width="1920" height="1168" alt="image" src="https://github.com/user-attachments/assets/f106bf48-5580-411b-af37-88fd93ec9a56" />
<img width="1920" height="1168" alt="image" src="https://github.com/user-attachments/assets/387dd5a5-062b-4af8-a83d-45b8441a9350" />
<img width="1920" height="1168" alt="image" src="https://github.com/user-attachments/assets/a811d3fd-8f72-422a-a97a-1bda255502d8" />

Try to understand buildconfig
```
oc project jegan
oc get buildconfigs
oc get builds
oc describe buildconfigs/hello
oc describe build/hello-1

oc get bc/hello -o yaml
```

## Lab - Deploying the application using S2I source strategy
```
oc delete project jegan
oc new-project jegan

oc new-app --name=hello registry.access.redhat.com/ubi8/openjdk-17~https://github.com/tektutor/spring-ms.git --strategy=source
oc expose svc/hello

oc logs -f bc/hello
oc get routes

curl http://hello-jegan.apps.ocp4.palmeto.org
```

<img width="1920" height="1168" alt="image" src="https://github.com/user-attachments/assets/54e6b8e1-eca9-462c-b38a-42636bb1aad1" />
<img width="1920" height="1168" alt="image" src="https://github.com/user-attachments/assets/5eb16938-97a0-4259-b35c-22ea360a271e" />
<img width="1920" height="1168" alt="image" src="https://github.com/user-attachments/assets/fb98c084-a059-472e-ad5c-ef027aa9edf8" />
<img width="1920" height="1168" alt="image" src="https://github.com/user-attachments/assets/c65886c8-e04a-45e3-9f2d-ae4c35db16b4" />
<img width="1920" height="1168" alt="image" src="https://github.com/user-attachments/assets/e7ebb893-e846-4f5f-bf4d-9c2f14e5f3be" />


Try to understand buildconfig
<pre>
oc project jegan
oc get buildconfigs
oc get builds
oc describe buildconfigs/hello
oc describe build/hello-1
oc get bc/hello -o yaml
</pre>

## Lab - Login to openshift from command-line
When it prompts for password, type the password shown in your openshift.txt file kept in your home directory
```
cd ~
cat openshift.txt
oc whoami
oc whoami --show-server
oc whoami --show-console
oc login -u kubeadmin https://api.ocp4.palmeto.org:6443 --insecure-skip-tls-verify=true
```

<img width="1920" height="1168" alt="image" src="https://github.com/user-attachments/assets/c7233014-c748-460e-81fc-4fe4a66a0e64" />

## Lab - List all pods with curl command
```
curl -k -H "Authorization: Bearer $(oc whoami -t)" -H "Accept: application/json" https://api.ocp4.palmeto.org:6443/api/v1/pods
```

## Lab - Deploying spring-boot application from Webconsole

Navigage to your Openshift webconsole
<img width="1920" height="1168" alt="image" src="https://github.com/user-attachments/assets/a275ba67-729e-490e-af29-20e093e8c902" />

Click Home-->Software Catalog
<img width="1920" height="1168" alt="image" src="https://github.com/user-attachments/assets/44da3923-2fe7-4fdf-b1a8-47d4d062f4b2" />
Search for "spring" and select "Basic SpringBoot"
Click "Create" button
<img width="1920" height="1168" alt="image" src="https://github.com/user-attachments/assets/7857e62b-1c9c-40a6-9883-6b82ad31c2b6" />
<img width="1920" height="1168" alt="image" src="https://github.com/user-attachments/assets/06874133-a39b-49f6-999c-af77881aa65e" />
Accept default and proceed to Click "Create"
<img width="1920" height="1168" alt="image" src="https://github.com/user-attachments/assets/3c980817-9a25-4890-80bd-93121c58e867" />
<img width="1920" height="1168" alt="image" src="https://github.com/user-attachments/assets/92a55104-5030-4a68-9685-dd22a3ae86e0" />
<img width="1920" height="1168" alt="image" src="https://github.com/user-attachments/assets/3bf50a13-4fe9-4189-bc87-0e0764da90d3" />
<img width="1920" height="1168" alt="image" src="https://github.com/user-attachments/assets/e9ca4647-11b1-44e4-9522-e8de77e655de" />
Click "Advanced"
<img width="1920" height="1168" alt="image" src="https://github.com/user-attachments/assets/f67e32e7-6ada-42f8-aba9-36f2d2b4c56c" />
Click "Accept Risk and Continue"
<img width="1920" height="1168" alt="image" src="https://github.com/user-attachments/assets/56a2e531-ece5-463f-a898-926c13026443" />

Delete Application from Webconsole
<img width="1920" height="1168" alt="image" src="https://github.com/user-attachments/assets/926cfba6-b411-407e-bb0b-88a249c67795" />
Click "Delete Application"
<img width="1920" height="1168" alt="image" src="https://github.com/user-attachments/assets/95c032ab-fcfb-48f3-83c0-ee41c6497894" />
<img width="1920" height="1168" alt="image" src="https://github.com/user-attachments/assets/9a009131-3d76-4504-b183-83e20ff7c95b" />
Click "Delete" button
<img width="1920" height="1168" alt="image" src="https://github.com/user-attachments/assets/efb2e703-db33-49bf-ac46-8b287d1e2d28" />

## Lab - Deploying a Simple Dot Net Application
Navigate to "Software Catalog" in Openshift Webconsole
<img width="1920" height="1168" alt="image" src="https://github.com/user-attachments/assets/5aa4834f-d1ff-423a-b253-5cd8eb152505" />
Select ".Net Application"
<img width="1920" height="1168" alt="image" src="https://github.com/user-attachments/assets/cafcd4b4-1367-4264-9d4b-7e0fce417d10" />

Click "Create" button
<img width="1920" height="1168" alt="image" src="https://github.com/user-attachments/assets/ce54cea0-76d0-46a4-9302-4b706fedc946" />

Click "Create" button
<img width="1920" height="1168" alt="image" src="https://github.com/user-attachments/assets/68d581d4-f5a2-4642-8f24-faf2e0963df9" />
<img width="1920" height="1168" alt="image" src="https://github.com/user-attachments/assets/06f5180f-d95e-4612-9c4e-56b0468305e5" />
<img width="1920" height="1168" alt="image" src="https://github.com/user-attachments/assets/de55dce7-0d38-44e0-82b2-6fcecad1a17f" />
<img width="1920" height="1168" alt="image" src="https://github.com/user-attachments/assets/5a91743d-fc73-4070-9b5d-22c67542bbe1" />

## Lab - Deploying application into Openshift using declarative style
```
oc delete project jegan
oc new-project jegan

oc create deploy nginx --image=image-registry.openshift-image-registry.svc:5000/openshift/nginx:1.0 --replicas=3 --dry-run=client -o yaml

oc create deploy nginx --image=image-registry.openshift-image-registry.svc:5000/openshift/nginx:1.0 --replicas=3 --dry-run=client -o yaml > nginx-deploy.yml
```

Let's declaratively deploy nginx web server using manifest file(yaml)
```
oc create -f nginx-deploy.yml --save-config
oc get deploy,rs,po
```
The above create command will assume the nginx deployment is not there already, if there is a deployment by name nginx already in your project, it will report error and quit. The save-config switch will save the meta-data in etcd database i.e using which yaml file we create this resource.  The next time, you made some delta change in the file and use the apply command it will validate wherether the resource was originally created using the same file nor not.

<img width="1920" height="1168" alt="image" src="https://github.com/user-attachments/assets/0ab3f150-3d1f-4607-b1c2-86a97a13e9f6" />
<img width="1920" height="1168" alt="image" src="https://github.com/user-attachments/assets/f5964bd7-fb12-4910-941a-3692e680a351" />

## Lab - Creating a clusterip internal service using declarative approach
```
oc project jegan
oc get deploy
oc expose deploy/nginx --type=ClusterIP --port=8080 --dry-run=client -o yaml
oc expose deploy/nginx --type=ClusterIP --port=8080 --dry-run=client -o yaml > nginx-clusterip-svc.yml
oc apply -f nginx-clusterip-svc.yml
oc get svc
```
<img width="1920" height="1168" alt="image" src="https://github.com/user-attachments/assets/90e208b7-497b-4fd2-977b-0e0c6cf1bd4a" />

## Lab - Creating a nodeport external service using declarative approach
```
oc project jegan
oc get deploy

# Delete the clusterip service, otherwise it will conflict with nodeport service
oc delete -f nginx-clusterip-svc.yml

# Create the nodeport external service
oc expose deploy/nginx --type=NodePort --port=8080 --dry-run=client -o yaml
oc expose deploy/nginx --type=NodePort --port=8080 --dry-run=client -o yaml > nginx-nodeport-svc.yml
oc apply -f nginx-nodeport-svc.yml

oc get svc

# Accessing nodeport service
curl http://<any-node-ip>:<node-port-shown-in-service-usually-30000-range>
curl http://192.168.100.11:31419 # Using master1 node IP
curl http://192.168.100.12:31419 # Using master2 node IP
curl http://192.168.100.13:31419 # Using master3 node IP
curl http://192.168.100.21:31419 # Using worker1 node IP
curl http://192.168.100.22:31419 # Using worker2 node IP
curl http://192.168.100.23:31419 # Using worker3 node IP
```
<img width="1920" height="1168" alt="image" src="https://github.com/user-attachments/assets/f7ba37c2-74cb-4aed-86f9-cbf85b13d184" />
<img width="1920" height="1168" alt="image" src="https://github.com/user-attachments/assets/86c29f83-4f62-4b91-88a5-14e65919c005" />
<img width="1920" height="1168" alt="image" src="https://github.com/user-attachments/assets/af9f4391-9857-4bb1-8f40-80d0ea72e11e" />

## Lab - Create the loadbalancer external service using declarative approach
```
# Make sure to delete existing nodeport service to avoid conflict
oc delete -f nginx-nodeport-svc.yml

oc expose deploy/nginx --type=LoadBalancer --port=8080 --dry-run=client -o yaml
oc expose deploy/nginx --type=LoadBalancer --port=8080 --dry-run=client -o yaml > nginx-lb-svc.yml
oc apply -f nginx-lb-svc.yml
oc get svc

curl http://<service-external-ip>:8080
curl http://192.168.100.25:8080
```

<img width="1920" height="1168" alt="image" src="https://github.com/user-attachments/assets/f5e8b12e-1c87-4e3a-8151-53d338f75b0a" />
<img width="1920" height="1168" alt="image" src="https://github.com/user-attachments/assets/cdf1605b-ad0f-40fd-8492-753c1d544481" />

## Info - ClusterIP vs NodePort vs LoadBalancer Service
<pre>
- ClusterIP is an service, this is used to provide access within the openshift cluster
- usually database access is allowed to application running within openshift, while restricting the access to external world
- nodeport - in case you have a frontend application or web application that must allowed external access you can go for noreport service.  However, nodeport service will be accessible only within your office/work network not from Internet
- loadbalancer - in case you wish to expose your application to your end-users over internet, go for loadbalancer service.  This provides a public static ip on public cloud environments like AWS, Azure, GCP, etc., but there will be an additional cost charged by AWS/Azure/GCP for the external loadbalancer
</pre>

## Info - Ingress Overview
<pre>
- Ingress is not a service
- Ingress is a Kubernetes native way to expose HTTP(s) public url to end-users outside the cluster
- Ingress has forward/routing rules
- Generally your openshift cluster will have any one of the Ingress Controllers
  1. Nginx Ingress Controller
  2. HAProxy Ingress Controller
  3. F5 Ingress Controller
- The Ingress Controller will be monitoring for new Ingress rules defined in any project namespace.  When it detects new ingress or ingress is updated, it picks those rules and configures the LoadBalancer with the rules mentioned in the ingress.
- We need to ensure, the correct Ingress Controller is annotated in your ingress rule. 
- Behind an ingress there could be multiple services ( clusterip, nodeport and load-balancer services )
- Behind each service service, there could be several pods from a single deployment
- Ingress forwards the request to the service behind, the service forward the request to one of the load-balanced pods
</pre>

## Info - Route Overview
<pre>
- is an Openshift feature, that is built on-top of kuberenetes ingress feature
- Behind a Kubernetes Ingress there will many services ( clusterip, nodeport and load-balancer services for different applications )
- Behind an Openshift Route there will just one service ( clusterip or nodeport or load-balancer service for just a single application)
- this is a neat way to expose your application for external access with a public url for a single applicaiton in Openshift
- Route is not supported in Kubernetes
</pre>

## Lab - Creating a ingress rule to foward requests to hello and nginx deployments
Clone the TekTutor Training Repository
```
cd ~
git clone https://github.com/tektutor/openshift-1317oct-2025.git
cd openshift-1317oct-2025
cd Day3/ingress
oc delete project jegan
oc new-project jegan

oc apply -f nginx-deploy.yml
oc apply -f nginx-svc.yml

oc apply -f hello-deploy.yml
oc apply -f hello-svc.yml

oc get pods
oc apply -f ingress.yml
oc get ingress
oc describe ingress/tektutor

curl http://tektutor.apps.ocp4.palmeto.org/nginx
curl http://tektutor.apps.ocp4.palmeto.org/tektutor
```
<img width="1920" height="1168" alt="image" src="https://github.com/user-attachments/assets/1471ffbf-53ad-4ca8-83d4-d8f2a52541d4" />
<img width="1920" height="1168" alt="image" src="https://github.com/user-attachments/assets/a678d81d-8a46-4426-aa0d-ae39ff1cbc61" />
<img width="1920" height="1168" alt="image" src="https://github.com/user-attachments/assets/ffe6b055-4a30-4920-a1a5-bc77c2cd7c90" />

## Lab - Rolling update 
```
cd ~/openshift-1317oct-2025
git pull
cd Day3/rolling-update
oc delete project jegan
oc new-project jegan

oc apply -f hello-deploy.yml
oc apply -f hello-svc.yml
oc apply -f hello-route.yml

oc get pods -o json | grep image # Here you can observer the image version used is hello:5.0
oc get routes
curl http://hello-jegan.apps.ocp4.palmeto.org # Here you will see Hello Microservice v5.0

#Let's perform rolling update by bumping up image version from 5.0 to 6.0 in the hello-deploy
oc apply -f hello-deploy.yml
oc get pods
oc rollout status deploy/hello
oc rollout history deploy/hello

oc get pods -o json | grep image # Here you can observer the image version used is hello:6.0
oc get routes
curl http://hello-jegan.apps.ocp4.palmeto.org # Here you will see Hello Microservice v6.0


# Let's undo the rolling update - it is supposed revert back to v5.0
oc rollout undo deploy/nginx
oc rollout status deploy/nginx
curl http://hello-jegan.apps.ocp4.palmeto.org # Here you will see Hello Microservice v5.0

```
